//Yohan Hernando González Gutiérrez - 6000615

<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta charset="utf-8" />
  <title>Figura de varios lados</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <script type="module">
    // Importaciones (Sacado de ChatGPT)
    import * as THREE from 'https://sebastiann16.github.io/CompG/three.module.js';
    import { OrbitControls } from 'https://sebastiann16.github.io/CompG/OrbitControls.js';
    var WIDTH = window.innerWidth;
    var HEIGHT = window.innerHeight;

    // Crea la escena
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(WIDTH, HEIGHT);
    renderer.setClearColor(0xFF7463, 1);
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    
    //  Crea la camra
    var camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT);
    camera.position.z = 30;
    camera.position.y = 15;
    scene.add(camera);
    const light = new THREE.AmbientLight(0xFFF866, 5);
    scene.add(light);

    // Funcion que crea los poligonos (Hecha en clase)
    function poligono(n, R) {
      var angulo = (2 * Math.PI) / n;
      // vertices
      var vertices = [];
      for (let i = 0; i < n + 1; i++) {
        vertices[i] = [
          R * Math.cos(i * angulo),
          R * Math.sin(i * angulo),
        ];
      }
      return vertices;
    }

    // Funcion que construye el poliedro
    function construirPoliedro(n, R, h) {

      // Crea la geometría del poliedro
      var geometria = new THREE.BufferGeometry();

      // Obtiene las coordenadas de los vértices en la base del poliedro
      var baseVertices = poligono(n, R);

      // Crea un array que almacenar los vértices
      var vertices = [];

      // Agregar los vértices a la matriz
      for (var i = 0; i < baseVertices.length; i++) {
        var x = baseVertices[i][0];
        var y = baseVertices[i][1];

// Agregar vértices base inferior
for (var i = 0; i < baseVertices.length; i++) {
  var x = baseVertices[i][0];
  var y = baseVertices[i][1];
  vertices.push(x, y, 0);
}

// Agregar vértices base superior
for (var i = 0; i < baseVertices.length; i++) {
  var x = baseVertices[i][0];
  var y = baseVertices[i][1];
  vertices.push(x, y, h);
}

// Convierte el array de vértices
var verticesArray = new Float32Array(vertices);

// Define los atributos de posición de la geometría
geometria.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));

// Crea las caras del poliedro
var indices = [];
for (var i = 0; i < n; i++) {
  var baseVerticeIndex = i;
  var siguienteBaseVerticeIndex = (i + 1) % baseVertices.length;
  var parteSuperiorVerticeIndex = baseVerticeIndex + baseVertices.length;
  var siguienteParteSuperiorVerticeIndex = siguienteBaseVerticeIndex + baseVertices.length;

  // Caras laterales
  indices.push(baseVerticeIndex, siguienteBaseVerticeIndex, parteSuperiorVerticeIndex);
  indices.push(siguienteBaseVerticeIndex, siguienteParteSuperiorVerticeIndex, parteSuperiorVerticeIndex);

  // Caras de la base inferior
  indices.push(baseVerticeIndex, siguienteBaseVerticeIndex, baseVerticeIndex + 1);

  // Caras de la base superior
  indices.push(parteSuperiorVerticeIndex, siguienteParteSuperiorVerticeIndex, parteSuperiorVerticeIndex + 1);
}

// Convierte el array de índices
var indicesArray = new Uint32Array(indices);

// Define los atributos de índices de la geometría
geometria.setIndex(new THREE.BufferAttribute(indicesArray, 1));

// Calcula las normales de las caras
geometria.computeVertexNormals();

// Crear el material y el objeto de malla
var material = new THREE.MeshBasicMaterial({ color: 0x00FFFB});
var poliedro = new THREE.Mesh(geometria, material);

// Devolver el poliedro
return poliedro;
      }
    }

    var poliedro = construirPoliedro(6, 1, 2);
    scene.add(poliedro);

    const controls = new OrbitControls(camera, renderer.domElement);
    const axesHelper = new THREE.AxesHelper(1000);
    scene.add(axesHelper);

    const size = 1000;
    const divisions = 1000;

    const gridHelper = new THREE.GridHelper(size, divisions);
    scene.add(gridHelper);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>

</html>